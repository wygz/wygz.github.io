<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 AIME I 解题思路（11~15）</title>
    <url>/2020/04/05/2020%20AIME%20I%20%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%8811~15%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/G_jsncAalP-vwNob1jbjJA" target="_blank" rel="noopener">微信公众号链接 - 2020 AIME I 解题思路（11~15）</a></p>
<p><a href="/downloads/2020 AIME I 解题思路 - 无忧公主的数学时间.pdf">pdf 下载链接 - 2020 AIME I 解题思路（1~15)</a></p>
<a id="more"></a>
<iframe  
 height=850 
 width=90% 
 src="/downloads/2020 AIME I 解题思路 - 无忧公主的数学时间.pdf"  
 frameborder=0  
 allowfullscreen>
 </iframe>



]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>1029 每日一题（烧脑数论）</title>
    <url>/2019/01/14/1029%20%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E7%83%A7%E8%84%91%E6%95%B0%E8%AE%BA%EF%BC%89/</url>
    <content><![CDATA[<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>证明：对于 $\forall n \in Z_+$，满足所有的 $n \choose m$ 中 mod 3 = 1 的个数大于 mod 3 = 2 的个数</p>
<a id="more"></a>
<p>链接：<a href="https://mp.weixin.qq.com/s/Cee6u7XlbuDekZrTIun5Nw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Cee6u7XlbuDekZrTIun5Nw</a></p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>由 Lucas 定理可知，将 $n$ 和 $m$ 分别写成三进制下的 $n_i$和 $m_i$，有 $\binom n m\equiv\prod \binom {n_i} {m_i}$ mod 3</p>
<p>观察 $\binom 0 0 \binom 0 1…\binom 2 2$，若要使 $\binom n m$ mod 3 ≠ 0，则 $m_i\leq n_i$</p>
<p>除了 $\binom 2 1\equiv -1$ 以外均为 1 ，因此 $\binom 2 1$ 个数的奇偶性决定了乘积是 $1$ 还是 $-1$</p>
<p>$n_i=0$ 时 $m_i=0$，而 $n_i=1$ 时 $m_i=0$ 或 $1$（根据乘法原理）均不影响结果</p>
<p>∴ 只需考虑 $n_i=2$ 的个数，不妨设为 $N$</p>
<p><strong>那么原问题等价于：</strong>有 $N$ 个球，每个球有 $\frac 13$ 的概率是白色的，有 $\frac 23$ 的概率是黑色的，即证一共有偶数个白球的概率大于奇数个白球的概率。也就是说，白球对应 $\binom 21$，黑球对应 $\binom 2 0$ 和 $\binom 2 2$</p>
<p>设 $dp[i][0]$ 表示前 $i$ 个球中有偶数个白球的概率，$dp[i][1]$ 表示前 $i$ 个球中有奇数个白球的概率，即证 $dp[i][0]&gt;dp[i][1]$</p>
<p>递推（转移）比较显然：设 $a=dp[i-1][0]$，$b=dp[i-1][1]$，那么 $dp[i][0]=\frac23a+\frac13b$，$dp[i][1]=\frac13a+\frac23b$</p>
<p>对 $i$ 数归：$i=1$ 时，$dp[i][0]=\frac23$，$dp[i][1]=\frac13$，$dp[i][0]&gt;dp[i][1]$ 成立</p>
<p>假设 $i-1$ 时已经满足 $a&gt;b$ 了，那么 $dp[i][0]=\frac13(2a+b)$，$dp[i][1]=\frac13(a+2b)$</p>
<p>$dp[i][0]-dp[i][1]=\frac13(a-b)&gt;0$，所以 $dp[i][0]&gt;dp[i][1]$</p>
<p><strong>至此，原问题即得证！</strong></p>
<p><strong>此外，我还有一些进一步的感想，如有错误希望能指出：</strong></p>
<p>注意到 $a+b=1$ 且 $i-1\rightarrow i$ 时 $a-b\rightarrow \frac13(a-b)$</p>
<p>这样一来，我们可以归纳出 $dp[i][0]$ 和 $dp[i][1]$ 的通项！</p>
<p>（此处省略若干字）设 $t=3^i$，那么 $dp[i][0]=\frac{(t-1)/2}{t}$，$dp[i][1]=\frac {(t+1)/2}{t}$</p>
<p>也就是说，当 $N$ 变大时，杨辉三角形第 $n$ 行里 mod 3 = 1 和 2 个数的比值，是在变大的</p>
<p>但是由于 $n_i$ 中 0 和 1 的存在，其个数在这一行里的比值是不确定的</p>
<p>实际上，当 $n_i$ 都是 2 即 $n=t-1$ 时，可以（找规律）发现这一行是 1 2 1 2 … 2 1 这个形式的，也验证了上述结论的正确性</p>
<p>感觉组合数 mod 3 还有可以继续深入的地方，但对更大的质数取模就会困难许多了</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Yahoo Programming Contest 2019 - F Pass</title>
    <url>/2019/02/10/AtCoder%20Yahoo%20Programming%20Contest%202019%20-%20F%20Pass/</url>
    <content><![CDATA[<p>题目来源：<a href="https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f" target="_blank" rel="noopener">https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_f</a></p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>首先将题目中的 “ 故事 ” 转化成限制条件：所得序列中第 $i$ 个球必然来自于第 $j$ $(j\leq i)$ 个人（不可能是第 $i$ 个人之后的球）</p>
<p>也就是说，序列的后 $n$ 个球没有特殊限制，在给定蓝色球数 $j$ 后乘上 $n\choose j$ 即可。重点在前 $n$ 个球，由于我们只关心序列中的颜色而非具体的人，那么限制的不过是前 $i$ 个球的<strong>蓝色球数</strong>不能超过前 $i$ 个人的前缀和 $s[i]$。</p>
<p>设 $dp[i][j]$ 表示前 $i$ 个球中蓝色球数为 $j$ 的序列个数，注意这里的 $j$ 有一定限制：$0\leq j\leq s[i]$，$2\cdot i-s[i]\geq i-j$（别忘了红色球），不满足条件时 $dp[i][j]=0$ 可以轻松防止访问。转移非常简单： $dp[i][j]=dp[i-1][j-1]+dp[i-1][j]$，最后统计答案就好啦！</p>
<p>P.S. 输入字符串中的 012 就是蓝色球的个数，于是前缀和处理起来很方便</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,s[maxn];</span><br><span class="line">ll dp[maxn][maxn*<span class="number">2</span>],ans,C[maxn][maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>); n=<span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">			C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="number">-1</span>]+S[i]-<span class="string">'0'</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=s[i];j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">2</span>*i-s[i]&lt;i-j) <span class="keyword">continue</span>;</span><br><span class="line">		dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">if</span> (j) dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">		<span class="keyword">if</span> (i==n) ans=(ans+dp[i][j]*C[n][s[n]-j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Yahoo Programming Contest 2019 - D Ears</title>
    <url>/2019/02/10/AtCoder%20Yahoo%20Programming%20Contest%202019%20-%20D%20Ears/</url>
    <content><![CDATA[<p>题目来源：<a href="https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_d" target="_blank" rel="noopener">https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_d</a></p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>归纳一下找规律的结论：不可以存在 全奇- 全偶 - 全奇 这样的形式，也就是说</p>
<p><strong>可行的 $a_1…a_n$ 必然可以分成 5 段（允许段不存在）：全 0 - 全偶 - 全奇 - 全偶 - 全 0</strong></p>
<p>之后的事情就好办多了，设 $dp[i][j]$ 表示使 $a_1…a_i$ 合法的最小操作数，且目前 $a_i$ 在第 $j$ 段里（将这 5 段标记为 0~4）</p>
<p>转移时 $dp[i-1][k] \rightarrow dp[i][j] ( k \leq j)$，再加上 $a_i$ 变成第 $j$ 段所需的操作数即可</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">'0'</span>&gt;ch||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;(t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>;ch=getchar();&#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll INF=(<span class="number">9e18</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">2e5</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line">ll dp[maxn][<span class="number">5</span>],ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (j==<span class="number">1</span>||j==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> a[i]&amp;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j==<span class="number">2</span>) <span class="keyword">return</span> a[i]&amp;<span class="number">1</span>^<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">4</span>;j++) &#123;</span><br><span class="line">		dp[i][j]=INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++)</span><br><span class="line">			dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][k]);</span><br><span class="line">		dp[i][j]+=op(i,j);</span><br><span class="line">		<span class="keyword">if</span> (i==n) ans=<span class="built_in">min</span>(ans,dp[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Parity</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Yahoo Programming Contest 2019 - E Odd Subrectangles</title>
    <url>/2019/02/10/AtCoder%20Yahoo%20Programming%20Contest%202019%20-%20E%20Odd%20Subrectangles/</url>
    <content><![CDATA[<p>题目来源：<a href="https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e" target="_blank" rel="noopener">https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_e</a></p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>将每行看作一个 m 位 01 二进制数，固定行集合 A 后选 B，那么 A 中元素的异或和上的每一位，即代表了这一列中与 A 交叉位置 1 的个数（的奇偶性）。也就是说，B 相当于选出 A 异或和中的若干位，如果这些位上异或和是 1（即有奇数个 1），则 A 和 B 构成的 “ 矩阵 ” 合法。A 异或和为 0（每一位都是 0）时显然不存在这样的 B，而 <strong>A 异或和不为 0 时恰有一半的 B 合法</strong>。</p>
<p>为什么呢？此时 A 的异或和中必然存在 1，不妨假设是第 0 位。那么对于第 1~m-1 位的任意一种选法 C，要使第 0 位与 C 的异或和为 1，第 0 位选 / 不选就已经由 C 确定了。B = 第 0 位选 / 不选 + C，这样一来，C 有 $2^{m-1}$ 种选法，B 自然也有 $2^{m-1}$ 种选法了（正好是一半哦）。于是，问题转化为求 A 异或和不为 0 的方案数 $S$，答案即为 $2^{m-1}\cdot S$，当然反过来求异或和为 0 更容易些。</p>
<p>下面考虑每一行上对应二进制数的线性基（套路？）。如果只选择线性基中的行集合 A，异或和不可能是 0，否则线性基去掉 A 后依然合法且更优（与线性基定义矛盾）。于是先选择线性基外的行集合 D，那么（根据定义）线性基中有且仅有一个集合 E 异或和相同（D ^ E = 0），换句话说每个 D 都唯一对应了一个 A。因此，$S=2^n-2^{n-cnt}$ 其中 $cnt$ 表示线性基大小，大功告成！</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">'0'</span>&gt;ch||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;(t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>;ch=getchar();&#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line">ll mi[maxn],ans;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; a,p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(m); mi[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(n,m);i++) mi[i]=mi[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">read</span>(x),a.<span class="built_in">set</span>(j,x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[j].none()) &#123; p[j]=a; cnt++; <span class="keyword">break</span>; &#125;</span><br><span class="line">			a^=p[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=(mi[n]-mi[n-cnt]+mod)*mi[m<span class="number">-1</span>]%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>CTS 2019 氪金手游</title>
    <url>/2019/05/20/CTS%202019%20%E6%B0%AA%E9%87%91%E6%89%8B%E6%B8%B8/</url>
    <content><![CDATA[<p>题目来源：<a href="https://loj.ac/problem/3124" target="_blank" rel="noopener">https://loj.ac/problem/3124</a></p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>最麻烦的地方在于 $w_i$ 不能直接赋为期望值，因此需要分开保留权值为 1、2、3 的概率</p>
<a id="more"></a>
<p>我们只关心第一次出现某张卡牌的先后关系，所以可以直接将序列看成排列；我们只关心权值之和，具体内部调整只需体现在概率上</p>
<p>在这棵有向树上进行树形 DP，表示子树内权值和确定（最终要用在分母上）且满足一切指向关系的对应概率</p>
<p>转移和背包有些类似，直接暴力枚举权值之和即可，注意指向关系需要分别讨论</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">'0'</span>&gt;ch||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;(t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>;ch=getchar();&#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,mx[<span class="number">1010</span>],head[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> tot,nxt[<span class="number">2010</span>],to[<span class="number">2010</span>];</span><br><span class="line">ll w[<span class="number">1010</span>][<span class="number">4</span>],tmp,ans;</span><br><span class="line">ll dp[<span class="number">3010</span>][<span class="number">3010</span>],DP[<span class="number">3010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	tot++; nxt[tot]=head[a];</span><br><span class="line">	head[a]=tot; to[tot]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">		x=x*x%mod; y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	mx[u]=<span class="number">3</span>;</span><br><span class="line">	dp[u][<span class="number">1</span>]=w[u][<span class="number">1</span>];</span><br><span class="line">	dp[u][<span class="number">2</span>]=w[u][<span class="number">2</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	dp[u][<span class="number">3</span>]=w[u][<span class="number">3</span>]*<span class="number">3</span>%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[u],v;i;i=nxt[i]) &#123;</span><br><span class="line">		v=to[i]; <span class="keyword">if</span> (v==p) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">		<span class="keyword">if</span> (i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mx[u];j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=mx[v];k++)</span><br><span class="line">				DP[j+k]=(DP[j+k]+dp[u][j]*dp[v][k]%mod)%mod;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mx[u];j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=mx[v];k++)</span><br><span class="line">				DP[j]=(DP[j]+dp[u][j]*dp[v][k]%mod)%mod,</span><br><span class="line">				DP[j+k]=(DP[j+k]-dp[u][j]*dp[v][k]%mod+mod)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		mx[u]+=mx[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=mx[u];j++) dp[u][j]=DP[j],DP[j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx[u];i++) dp[u][i]=dp[u][i]*ksm(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a); <span class="built_in">read</span>(b); <span class="built_in">read</span>(c);</span><br><span class="line">		tmp=ksm(a+b+c,mod<span class="number">-2</span>);</span><br><span class="line">		w[i][<span class="number">1</span>]=a*tmp%mod;</span><br><span class="line">		w[i][<span class="number">2</span>]=b*tmp%mod;</span><br><span class="line">		w[i][<span class="number">3</span>]=c*tmp%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(a); <span class="built_in">read</span>(b);</span><br><span class="line">		add(a,b); add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx[<span class="number">1</span>];i++)</span><br><span class="line">		ans=(ans+dp[<span class="number">1</span>][i])%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTS</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1332G No Monotone Triples</title>
    <url>/2020/04/04/CF1332G%20No%20Monotone%20Triples/</url>
    <content><![CDATA[<p>给定 $\{a_n\}$，$q$ 次询问区间 $[l,r]$，求其中最长的子序列（可不连续）满足最长递增、递减（相等也算）子序列均 $\le 2$，若该子序列最长 $\le 2$ 则输出 $0$，否则输出长度+例子，$n,q\le 2\cdot 10^5$。</p>
<a id="more"></a>
<p>由 Erdos-Szekeres 定理，任何长度为 $mn+1$ 的序列中存在长度为 $m+1$ 的递增子序列，或长度为 $n+1$ 的递减子序列。也就是说，题目中的 $[l,r]$ 内子序列最长为 $4$。</p>
<p>而长度为 $3$ 的非常好找，只要对每个 $a_i$ 找到左/右第一个比自己严格大/小的位置，用大小严格比较的单调栈做。这样会构成可能的答案区间，对所有 $l$ 取后面对应最小的 $r$ 即可，不用区间排序+线段树之类的了。</p>
<p>下面考虑长度为 $4$ 的情况，假设其中最左、最右的数位于 $L,R$。</p>
<p>观察定理本身的取等条件，这 $4$ 个数会长成什么样子？必须是中间两数一个 max，一个 min，左右两数夹在中间，且不碰到 max、min，但左右可以相等。如果具体讨论大小关系，套单调栈+主席树+线段树+上面二分，大约是 $\mathcal O(n\log ^2n)$ 和一堆常数，比较困难。</p>
<p>在刚才构思的实现中，我们会发现，对 $L$ 来说 $R$ 是“好”的当且仅当 $R$ 不是 $[L,R]$ 中的 max 或 min。而且选出其中最小的 $R$ 以后，可以用 ST 表找到 $[L,R]$ 中的 max 和 min 作为中间两数，构成答案。而满足 $R$ 是 $[L,R]$ 中 max 或 min 的 $R$，一定是在（从右往左扫）当前两个单调栈内的（大小非严格，允许相同）。</p>
<p>在沿用单调栈的基础上，用 set 维护不出现在任何单调栈内的所有数。为了避免栈顶连续一段都相等，我们二分找到第一个不等的位置，找到这 $2$ 个位置后面 set 中最小的 $R$ 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123; (t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>; ch=getchar(); &#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">2e5</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=(<span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],tot,cnt[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans3[maxn],ans4[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> l,mid,r,z; &#125; d[maxn],e[maxn];</span><br><span class="line"><span class="keyword">int</span> s1[maxn],t1,s2[maxn],t2;</span><br><span class="line"><span class="keyword">int</span> L1[maxn],R1[maxn],L2[maxn],R2[maxn];</span><br><span class="line"><span class="keyword">int</span> mn[maxn][<span class="number">20</span>],mx[maxn][<span class="number">20</span>],lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,node A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d[x].r&gt;A.r) d[x]=A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i].r=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (t1&amp;&amp;a[s1[t1]]&gt;=a[i]) t1--;</span><br><span class="line">		<span class="keyword">while</span> (t2&amp;&amp;a[s2[t2]]&lt;=a[i]) t2--;</span><br><span class="line">		L1[i]=s1[t1],L2[i]=s2[t2];</span><br><span class="line">		s1[++t1]=i; s2[++t2]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	t1=t2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> (t1&amp;&amp;a[s1[t1]]&gt;=a[i]) t1--;</span><br><span class="line">		<span class="keyword">while</span> (t2&amp;&amp;a[s2[t2]]&lt;=a[i]) t2--;</span><br><span class="line">		R1[i]=s1[t1],R2[i]=s2[t2];</span><br><span class="line">		s1[++t1]=i; s2[++t2]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L1[i]&amp;&amp;R1[i]) &#123;</span><br><span class="line">			update(L1[i],(node)&#123;L1[i],i,R1[i]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (L2[i]&amp;&amp;R2[i]) &#123;</span><br><span class="line">			update(L2[i],(node)&#123;L2[i],i,R2[i]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		update(i,d[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> x,node A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e[x].z&gt;A.z) e[x]=A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,l,r,p1,p2,mid,L,R;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mn[i][<span class="number">0</span>]=mx[i][<span class="number">0</span>]=i,e[i].z=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">19</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) &#123;</span><br><span class="line">			x=mn[i][j<span class="number">-1</span>],y=mn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (a[x]&lt;a[y]) mn[i][j]=x;</span><br><span class="line">			<span class="keyword">else</span> mn[i][j]=y;</span><br><span class="line">			x=mx[i][j<span class="number">-1</span>],y=mx[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (a[x]&gt;a[y]) mx[i][j]=x;</span><br><span class="line">			<span class="keyword">else</span> mx[i][j]=y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t1=t2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n,j;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> (t1&amp;&amp;a[s1[t1]]&gt;a[i]) &#123;</span><br><span class="line">			cnt[s1[t1]]--;</span><br><span class="line">			<span class="keyword">if</span> (!cnt[s1[t1]]) s.insert(s1[t1]);</span><br><span class="line">			t1--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (t2&amp;&amp;a[s2[t2]]&lt;a[i]) &#123;</span><br><span class="line">			cnt[s2[t2]]--;</span><br><span class="line">			<span class="keyword">if</span> (!cnt[s2[t2]]) s.insert(s2[t2]);</span><br><span class="line">			t2--;</span><br><span class="line">		&#125;</span><br><span class="line">		l=<span class="number">1</span>,r=t1,p1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">			mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[s1[mid]]&lt;a[i]) p1=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		l=<span class="number">1</span>,r=t2,p2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">			mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[s2[mid]]&gt;a[i]) p2=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p1&amp;&amp;p2) &#123;</span><br><span class="line">			L=<span class="built_in">max</span>(s1[p1],s2[p2]);</span><br><span class="line">			it=s.upper_bound(L);</span><br><span class="line">			<span class="keyword">if</span> (it!=s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				R=*it;</span><br><span class="line">				L=i;</span><br><span class="line">				j=lg[R-L+<span class="number">1</span>];</span><br><span class="line">				x=mn[L][j],y=mn[R-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">if</span> (a[x]&lt;a[y]) p1=x; <span class="keyword">else</span> p1=y;</span><br><span class="line">				x=mx[L][j],y=mx[R-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">if</span> (a[x]&gt;a[y]) p2=x; <span class="keyword">else</span> p2=y;</span><br><span class="line">				update2(i,(node)&#123;i,<span class="built_in">min</span>(p1,p2),<span class="built_in">max</span>(p1,p2),R&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s1[++t1]=i; s2[++t2]=i;</span><br><span class="line">		cnt[i]+=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		update2(i,e[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) lg[i]=lg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	solve1();</span><br><span class="line">	solve2();</span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(l); <span class="built_in">read</span>(r);</span><br><span class="line">		<span class="keyword">if</span> (e[l].z&lt;=r) <span class="built_in">printf</span>(<span class="string">"4\n%d %d %d %d\n"</span>,e[l].l,e[l].mid,e[l].r,e[l].z);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (d[l].r&lt;=r) <span class="built_in">printf</span>(<span class="string">"3\n%d %d %d\n"</span>,d[l].l,d[l].mid,d[l].r);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0. Enough array size? Enough array size? Enough array size? Interger overflow?</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  1. Think TWICE, Code ONCE!</span></span><br><span class="line"><span class="comment">  Are there any counterexamples to your algo?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  2. Be careful about the BOUNDARIES!</span></span><br><span class="line"><span class="comment">  N=1? P=1? Something about 0?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  3. Do not make STUPID MISTAKES!</span></span><br><span class="line"><span class="comment">  Time complexity? Memory usage? Precision error?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>近期在线比赛链接</title>
    <url>/2020/04/07/Recent-and-Upcoming-Contests/</url>
    <content><![CDATA[<h5 id="Upcoming-Contests"><a href="#Upcoming-Contests" class="headerlink" title="Upcoming Contests"></a>Upcoming Contests</h5><p>04/10（周五）    22:35    <a href="https://codeforces.com/contests" target="_blank" rel="noopener">Edu. Codeforces Round 85</a></p>
<a id="more"></a>
<h5 id="Recent-Contests"><a href="#Recent-Contests" class="headerlink" title="Recent Contests"></a>Recent Contests</h5><p>04/08（周三）    22:35     <a href="https://codeforces.com/contest/1333" target="_blank" rel="noopener">Codeforces Round #632 (Div. 2)</a><br>04/04（周六）    20:00     <a href="https://atcoder.jp/contests/abc161" target="_blank" rel="noopener">AtCoder Beginner Contest 161</a><br>04/03（周五）    22:35     <a href="https://codeforces.com/contest/1329" target="_blank" rel="noopener">Codeforces Round #631 (Div. 1)</a><br>04/03（周五）    22:35     <a href="https://codeforces.com/contest/1330" target="_blank" rel="noopener">Codeforces Round #631 (Div. 2)</a></p>
]]></content>
  </entry>
  <entry>
    <title>CTS 2019 随机立方体</title>
    <url>/2019/05/20/CTS%202019%20%E9%9A%8F%E6%9C%BA%E7%AB%8B%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p>题目来源：<a href="https://loj.ac/problem/3119" target="_blank" rel="noopener">https://loj.ac/problem/3119</a></p>
<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>在一个 $n\times m\times l$ 立方体的每个格子上，随机不重复地填上 $1$ 到 $n\times m\times l$（排列）</p>
<p>定义一个格子是极大的，当且仅当它比所有至少有一维坐标相同的格子，数值都要大</p>
<p>求恰好有 $k$ 个极大格子的概率，答案取模。</p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>首先将恰好有 $k$ 个极大的转化成至少有 $i$ 个极大的并容斥（自行意会）</p>
<p>以 $k=2$ 为例，假设当前两个极大格所填数为 $a_1$ 和 $a_2$，与 $a_1$ 至少一维相同的格子记为 $S_1$，与 $a_2$ 至少一维相同的格子记为 $S_2$</p>
<p>不妨 $a_1&gt;a_2$，我们要使得 $a_1$ 是 $S_1\cup S_2$ 中的最大值，$a_2$ 是 $S_2$ 中的最大值，注意到两个事件独立，则概率（分别为 “ 集合大小分之一 ”）可以连乘</p>
<p>推广到 $a_1&gt;a_2&gt;…&gt;a_i$ 也是完全一样的道理，因此可以直接预处理出概率的前缀积 $|S_1\cup S_2\cup …\cup S_i|=n\times m\times l-(n-i)(m-i)(l-i)$</p>
<p>最后在统计至少有 $i$ 个极大格子的概率时，还需乘上 $\binom ik$ 表示选出真正的 $k$ 个极大格，以及从 $n$ 或 $m$ 或 $l$ 中选出 $i$ 行摆放的方案数</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">'0'</span>&gt;ch||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;(t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>;ch=getchar();&#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">ll n,m,l,k,ans,N,tmp;</span><br><span class="line">ll a[maxn],b[maxn];</span><br><span class="line">ll jc[maxn],iv[maxn],ivjc[maxn];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x,ll y)</span> </span>&#123; x%=mod;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">		x=x*x%mod; y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> jc[x]*ivjc[y]%mod*ivjc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> jc[x]*ivjc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	jc[<span class="number">0</span>]=iv[<span class="number">0</span>]=ivjc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	jc[<span class="number">1</span>]=iv[<span class="number">1</span>]=ivjc[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++) &#123;</span><br><span class="line">		jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		iv[i]=(mod-mod/i)*iv[mod%i]%mod;</span><br><span class="line">		ivjc[i]=ivjc[i<span class="number">-1</span>]*iv[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">read</span>(n); <span class="built_in">read</span>(m); <span class="built_in">read</span>(l); <span class="built_in">read</span>(k);</span><br><span class="line">		N=<span class="built_in">min</span>(n,<span class="built_in">min</span>(m,l)); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) a[i]=(n*m%mod*l%mod-(n-i)*(m-i)%mod*(l-i)%mod+mod)%mod;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) b[i]=b[i<span class="number">-1</span>]*a[i]%mod;</span><br><span class="line">		b[N]=ksm(b[N],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) b[i]=b[i+<span class="number">1</span>]*a[i+<span class="number">1</span>]%mod;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=k;i&lt;=N;i++) &#123;</span><br><span class="line">			tmp=C(i,k)*b[i]%mod*A(n,i)%mod*A(m,i)%mod*A(l,i)%mod;</span><br><span class="line">			<span class="keyword">if</span> (i%<span class="number">2</span>==k%<span class="number">2</span>) ans+=tmp; <span class="keyword">else</span> ans-=tmp;</span><br><span class="line">			<span class="keyword">if</span> (ans&gt;=mod) ans-=mod; <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTS</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2020 Open Platinum T1 Sprinklers 2 - Return of the Alfalfa</title>
    <url>/2020/04/06/USACO%202020%20Open%20Platinum%20T1/</url>
    <content><![CDATA[<p>链接：<a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=1044" target="_blank" rel="noopener">http://usaco.org/index.php?page=viewproblem2&amp;cpid=1044</a></p>
<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>FJ 有一块 $N \times N$ 的田地，可以种 sweet corn 和 alfalfa。在一个格子装 sweet corn sprinkler 可以使左下的格子都长出 sweet corn，装 alfalfa sprinkler 可以使右上的格子都长出 alfalfa。如果一个格子同时被两种覆盖到，则长不出任何东西；否则可以顺利长出相应的作物，允许多次覆盖。已知某些格子无法装 sprinkler，不过仍然可以长作物。FJ 希望每个格子都能长出作物来，求初始装 sprinkler 的方案数，对 $10^9+7$ 取模。</p>
<p>范围：$1 \le N \le 2000$，给出能否装 sprinkler 的 01 矩阵。</p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>最终种出的作物一定分居轮廓线两侧，左下 sweet corn，右上 alfalfa，且转角处必须安装相应的 sprinkler。我们只关心每一行最后一个 sweet corn 在哪里，因此可设 $dp[i][j]$ 表示考虑前 $i$ 行且第 $i$ 行前 $j$ 格长 sweet corn 的方案数，即轮廓线转角。记得特判 $i=1,n$ 和 $j=0,n$，如果第 $1$ 或 $n$ 行都不让装 sprinkler 答案为 $0$。</p>
<p>转移时枚举上一行，需要乘上相应的 $2$ 的幂次，因为除了强制装 sprinkler 的格子以外，其余要么不让装，要么可装可不装。写完 $\mathcal O(n^3)$ 版本先交上去检查正确性，然后用前缀和优化就是 $\mathcal O(n^2)$ 了。</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123; (t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>; ch=getchar(); &#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=(<span class="number">1e9</span>)+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,mi[<span class="number">2010</span>],cnt[<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">char</span> d[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>],sum[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> iv,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x+=y; <span class="keyword">if</span> (x&gt;=mod) x-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"sprinklers2.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"sprinklers2.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,d[i]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span> (d[i][j]==<span class="string">'.'</span>) cnt[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	iv=mod-mod/<span class="number">2</span>;</span><br><span class="line">	mi[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) mi[i]=mi[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">if</span> (cnt[<span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span> (d[<span class="number">1</span>][j]==<span class="string">'.'</span>) dp[<span class="number">1</span>][j]=mi[cnt[<span class="number">1</span>]<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>]=mi[cnt[<span class="number">1</span>]];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j) sum[<span class="number">1</span>][j]=sum[<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span> (j&lt;n&amp;&amp;d[<span class="number">1</span>][j+<span class="number">1</span>]==<span class="string">'.'</span>)</span><br><span class="line">			update(sum[<span class="number">1</span>][j],dp[<span class="number">1</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			dp[i][j]=(ll)dp[i<span class="number">-1</span>][j]*mi[cnt[i]]%mod;</span><br><span class="line">			<span class="keyword">if</span> (j&amp;&amp;d[i][j]==<span class="string">'.'</span>) &#123;</span><br><span class="line">				update(dp[i][j],(ll)sum[i<span class="number">-1</span>][j<span class="number">-1</span>]*iv%mod*mi[cnt[i]<span class="number">-1</span>]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j) sum[i][j]=sum[i][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (j&lt;n&amp;&amp;d[i][j+<span class="number">1</span>]==<span class="string">'.'</span>)</span><br><span class="line">				update(sum[i][j],dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">if</span> (d[n][j+<span class="number">1</span>]==<span class="string">'.'</span>)</span><br><span class="line">			update(ans,(ll)dp[n][j]*iv%mod);</span><br><span class="line">	update(ans,dp[n][n]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0. Enough array size? Enough array size? Enough array size? Interger overflow?</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  1. Think TWICE, Code ONCE!</span></span><br><span class="line"><span class="comment">  Are there any counterexamples to your algo?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  2. Be careful about the BOUNDARIES!</span></span><br><span class="line"><span class="comment">  N=1? P=1? Something about 0?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  3. Do not make STUPID MISTAKES!</span></span><br><span class="line"><span class="comment">  Time complexity? Memory usage? Precision error?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CTS 2019 珍珠</title>
    <url>/2019/05/22/CTS%202019%20%E7%8F%8D%E7%8F%A0/</url>
    <content><![CDATA[<p>题目来源：<a href="https://loj.ac/problem/3120" target="_blank" rel="noopener">https://loj.ac/problem/3120</a></p>
<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>有 $n$ 个在 $[1,D]$ 范围内的随机变量，求使得相同变量能够配成至少 $m$ 对的方案数（$1\le D\le 10^5，1\le m\le n\le 10^9$）</p>
<a id="more"></a>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>根据 ECNU 游族杯 2019 的抽乌龟那题，可以轻松获得 50+ 的部分分，并联想到权值出现次数为奇数的个数 $\le n-2m$</p>
<p>根据出现次数考虑生成函数，由 $\sum\frac {x^k}{k!}$ 联想到一些前置技能：</p>
<script type="math/tex; mode=display">
\begin{aligned}
1+x+\frac {x^2} {2!}+\frac {x^3}{3!}+...&=e^x\\
1-x+\frac {x^2} {2!}-\frac {x^3}{3!}+...&=e^{-x}\\
1+\frac {x^2} {2!}+\frac {x^4} {4!}+\frac {x^6} {6!}+...&=\frac {e^x+e^{-x}} 2\\
x+\frac {x^3} {3!}+\frac {x^5} {5!}+\frac {x^7} {7!}+...&=\frac {e^x-e^{-x}} 2
\end{aligned}</script><p>于是出现偶数次的生成函数为 $\frac {e^x+e^{-x}} 2$，出现奇数次的生成函数为 $\frac {e^x-e^{-x}} 2$。我们所求的答案如下，其中 $[x^n]$ 表示求 $x^n$ 的系数，$y$ 表示出现奇数次的个数。显然，只有当 $x$ 刚好被选择了 $n$ 个且 $y$ 不超过 $n-2m$ 个时，需要统计如答案，接着便可以进行一系列的化简：</p>
<script type="math/tex; mode=display">
n!\sum_{k=0}^{n-2m}(\frac {e^x+e^{-x}} 2+y\frac {e^x-e^{-x}} 2)^D[x^n][y^k]\\
\begin{aligned}
&=n!\frac 1 {2^D}\sum_{k=0}^{n-2m}(e^x(1+y)+e^{-x}(1-y))^D[x^n][y^k]\\
\end{aligned}</script><p>使用两次二项式定理，将 D 次方展开、交换求和顺序即可直接消去 $[x^n]$</p>
<script type="math/tex; mode=display">
\begin{aligned}
&=n!\frac 1 {2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^D(e^x(1+y))^i(e^{-x}(1-y))^{D-i}[x^n][y^k]\\
&=n!\frac 1 {2^D}\sum_{k=0}^{n-2m}\sum_{i=0}^D\binom Die^{(2i-D)x}(1+y)^i(1-y)^{D-i}[x^n][y^k]\\
&=\frac 1 {2^D}\sum_{i=0}^D\binom Di(2i-D)^n\sum_{k=0}^{n-2m}(1+y)^i(1-y)^{D-i}[y^k]\\
\end{aligned}</script><p>当 $i$ 确定时，我们只需考虑 $S=\sum_{k=0}^{n-2m}(1+y)^i(1-y)^{D-i}[y^k]$ 的求法。当 $i=D$ 时暴力枚举 $k$ 即可，当 $i≠D$ 时可以将 $[y^k]$ 换个形式：</p>
<script type="math/tex; mode=display">
S=(1+y)^i(1-y)^{D-i}(1+y+y^2+...)[y^{n-2m}]</script><p>后面的 $1+y+y^2+…=\frac 1{1-y}$ 即为补足指数的部分，这样的好处在于多出可以抵消掉的 $1-y$ 与指数统一的 $y^{n-2m}\implies S=(1+y)^i(1-y)^{D-i-1}[y^{n-2m}]$</p>
<p>$(1+y)^i$ 取指数 $j$，$(1-y)^{D-i-1}$ 取指数 $n-2m-j$，因此 $S=\sum_{j=0}^k\binom ij\binom{d-i}{k-j}$，其中便于书写设 $d=D=1,k=n-2m$</p>
<script type="math/tex; mode=display">
\sum_{j=0}^k\binom ij\binom{d-i}{k-j}=\sum_{j=0}^k\frac{i!}{j!(i-j)!}\cdot\frac{(d-i)!}{(k-j)!(d-k-i+j)}</script><p>此时如果将 $j$ 和 $i-j$ 看成指数，那么已经是卷积形式了——对应指数为 $i$ 的系数，而且不需要对于每个 $i$ 单独计算，直接跑一遍 NTT 即可</p>
<p>最后别忘了 $i=D$ 需单独处理，以及前面剩下的系数 $\frac 1 {2^D}\binom Di(2i-D)^n$</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>终于推导完啦，现在只要把公式都敲进去就好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">"="</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="string">'0'</span>&gt;ch||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;(t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>;ch=getchar();&#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">5e5</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,D,N,d,k;</span><br><span class="line">ll jc[maxn],iv[maxn],ivjc[maxn];</span><br><span class="line">ll a[maxn],b[maxn],fa[maxn],fb[maxn];</span><br><span class="line">ll rev[maxn],ans,tmp;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&lt;<span class="number">0</span>) x+=mod;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">		x=x*x%mod; y/=<span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> jc[x]*ivjc[y]%mod*ivjc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	N=<span class="number">1</span>; <span class="keyword">int</span> lg=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (N&lt;n) N*=<span class="number">2</span>,lg++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>,ii=i;j&lt;=lg;j++,ii/=<span class="number">2</span>)</span><br><span class="line">			rev[i]=rev[i]*<span class="number">2</span>+(ii%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(ll *a,ll *out,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> ll tmp[maxn];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) tmp[rev[i]]=a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">1</span>;<span class="built_in">step</span>&lt;N;<span class="built_in">step</span>*=<span class="number">2</span>) &#123;</span><br><span class="line">		ll wn=ksm(<span class="number">3</span>,(mod<span class="number">-1</span>)/(<span class="built_in">step</span>*<span class="number">2</span>));</span><br><span class="line">		<span class="keyword">if</span> (flag==<span class="number">-1</span>) wn=ksm(wn,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=<span class="built_in">step</span>*<span class="number">2</span>) &#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;i+<span class="built_in">step</span>;k++) &#123;</span><br><span class="line">				ll u=tmp[k],v=tmp[k+<span class="built_in">step</span>]*w%mod;</span><br><span class="line">				tmp[k]=(u+v)%mod; tmp[k+<span class="built_in">step</span>]=(u-v+mod)%mod;</span><br><span class="line">				w=w*wn%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) out[i]=tmp[i];</span><br><span class="line">	<span class="keyword">if</span> (flag==<span class="number">-1</span>) &#123;</span><br><span class="line">		ll t=ksm(N,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			out[i]=out[i]*t%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	jc[<span class="number">0</span>]=iv[<span class="number">0</span>]=ivjc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	jc[<span class="number">1</span>]=iv[<span class="number">1</span>]=ivjc[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn/<span class="number">5</span>;i++) &#123;</span><br><span class="line">		jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		iv[i]=(mod-mod/i)*iv[mod%i]%mod;</span><br><span class="line">		ivjc[i]=ivjc[i<span class="number">-1</span>]*iv[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">read</span>(D); <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); d=D<span class="number">-1</span>; k=<span class="built_in">min</span>(D,n<span class="number">-2</span>*m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++) &#123;</span><br><span class="line">		a[j]=ivjc[j]*ivjc[k-j]%mod;</span><br><span class="line">		<span class="keyword">if</span> ((k-j)&amp;<span class="number">1</span>) a[j]=mod-a[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=d-k;j++) b[j]=ivjc[j]*ivjc[d-k-j]%mod;</span><br><span class="line">	init(d*<span class="number">2</span>);</span><br><span class="line">	fft(a,fa,<span class="number">1</span>); fft(b,fb,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) fa[i]=fa[i]*fb[i]%mod;</span><br><span class="line">	fft(fa,a,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++) a[i]=a[i]*jc[i]%mod*jc[d-i]%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;i++)</span><br><span class="line">		ans=(ans+a[i]*C(D,i)%mod*ksm(<span class="number">2</span>*i-D,n)%mod)%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) tmp=(tmp+C(D,i))%mod;</span><br><span class="line">	ans=(ans+tmp*ksm(D,n)%mod)%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans*ksm(ksm(<span class="number">2</span>,mod<span class="number">-2</span>),D)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTS</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Miller Rabin 与 Pollard Rho——大整数分解质因数</title>
    <url>/2018/08/30/Miller%20Rabin%20%E4%B8%8E%20Pollard%20Rho/</url>
    <content><![CDATA[<blockquote>
<p>分解质因数本身并不困难，直接枚举的 $O(\sqrt{n})$ 做法在大部分情况中也都适用，今天我想介绍一种更高效但 “ 玄学 ” 的做法——Pollar Rho，这时 Miller Rabin 也会派上用场呢。</p>
</blockquote>
<a id="more"></a>
<h5 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h5><p>Miller Rabin 和 Pollard Rho 本质上都是随机算法，你有没有想过随机出任何一个质因数呢？你可能会说，当 $N=p1*p2$ 的时候，很难随机到呀！但是，随机选 23 个人，他们中有两人生日相同的概率是超过 50% 的——这里，生日悖论是个很好的例子。它的证明很好理解，假设第 1 个人已经选好了，那么第 2 个人生日与他不相同的概率为 $1-\frac 1 {365}$，第 3 个人与他们都不相同的概率为 $1-\frac 2 {365}$……以此类推。这样相乘起来，即可得出的结论是（这里就不给出严谨过程了，因为并不是重点…）：如果一年有 $N$ 天，那么只要 $n\geq\sqrt{N}$，随机选 $n$ 个人中有生日相同的概率超过 50%。</p>
<p>于是拓展到原来的问题，我们知道当 $n=\sqrt{N}$ 时，概率会达到 50%。直接随机 $\sqrt{N}$ 个数的代价是不可取的，但如果两两作差就有意思了，因为理论上来说只需要随机 $N^{1/4}$ 个数。此时的问题在于概率还不够大，并仍然需要枚举他们的差、再做除法，以找到一个质因数。进一步思考，取 $gcd(|a-b|,N)$ 时是非常优秀的，原因在于虽然 $p1$ 和 $p2$ 很难找，但 $p1$ 和 $p2$ 的倍数比比皆是，所以满足$1&lt;gcd&lt;N$ 时便找到一个因数啦。</p>
<h5 id="实现方法及细节"><a href="#实现方法及细节" class="headerlink" title="实现方法及细节"></a>实现方法及细节</h5><p>等一下，我们还是要存储 $N^{1/4}$ 个数吗？Pollard 告诉我们，只需要判断两个数哦。具体来说，我们先随机出 $x_1$，然后构造出一个很好的伪随机函数 $f(x)=(x^2+c)$ mod $N$ 来生成出下一项，也就是 $x_{n+1}=f(x_n)$。你会发现这样能通过大部分的数据，但也有可能陷入死循环，而永远找不到 $1&lt;gcd&lt;N$ 的情况（这时便找不到因数，需要换个 $c$ 再做一遍）。</p>
<p>$*$ 并不是所有伪随机函数都适用</p>
<p>用 $vis$ 记录是显然存不下的，于是 Floyd 发明了一个判环的方法。假设 $a$ 和 $b$ 同时从起点出发开始跑 $f(x)$，$b$ 比 $a$ 要快一倍，如果有环则很快会追上。按照这样的思路，从代码实现角度来说，$b$ 可以记录上一个 $2^k$ 的 $x$ 值，与 $a$ 进行比较、作差取 $gcd$，出现环时也能迅速判断到。</p>
<p>剩下需要做的就是维护好递归，每次先顺利找到一个因数 $p$，再分别对 $p$ 和 $N/p$ 进行类似的分解操作。当 $p$ 是质数时，就不需要继续了——这至关重要，否则很难判断。于是  Miller Rabin 就登场啦，我想细致地讲一遍实现方法。首先假设 $p-1=2^k<em>t$ 且 $t$ 是奇数（把 2 都除掉），那么快速幂求得 $a^t$mod $p$ 后就可以自乘依次获得 $a^{2t}$、$a^{4t}$……$a^{2^k</em>t}$ 也就是 $a^{p-1}$。在这个过程当中，如果出现前 1 项不是 ±1 而后一项是 1，或者 $a^{p-1}$ mod $p$ 不是 1，则 $p$ 不是质数。这里的 $a$ 我取的是 2~23 的质数，当然 $p$ 要先判下是不是 $a$ 的倍数。</p>
<p>$*$ 如果 $p$ 是质数，那么 $a^2\equiv 1$ 等价于 $a\equiv ±1$。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总的来说，这个做法在 $N$ 的因数很多且都不大时尤其高效，但因为是随机的所以看起来比较 “ 玄学 ”，下面我想严谨证明一下期望复杂度。假设 $p1\leq p2$ 且 $y_i=x_i$ mod $p1$，根据生日悖论，$x_i$ 进入循环的期望步数是 $\sqrt{N}$ 而 $y_i$ 是 $\sqrt{p1}$。所以在 $y_i$ 进入循环后，$x_i$ 很可能还没有，此时 $x_i-x_j=(k1\cdot p1+y_i)-(k2\cdot p1+y_j)=(k_i-k_j)\cdot p1$ 因为 $y_i=y_j$。此时已经通过 $x_i-x_j$ 的 $gcd$ 已经找出了 $p1$ 这个因数，又因为 $p1\leq\sqrt{N}$，所以 $y_i$ 进入循环的期望步数是 $O(N^{1/4})$——如果复杂度不计常数的话。</p>
<p>其实最初 Pollard 在 1975 年发表了这个算法，之后再在 1980 年由 Richard Brent 提出了改进。关于 Pollard Rho 算法这个名字，其实非常有意思：进入一个 Floyd 循环的过程，是不是长的很像 $ρ$ 呢？</p>
<p>$*$ 我们不能直接将两个 $N$ 级别的 long long 相乘（带取模的），尽管结果是 long long。可以把 $a\cdot b$ 看成 $b$ 个 $a$ 相加，再用类似快速幂的方法计算，当然快速幂也需要注意这个乘法问题。对了，这样算出来的质因数是无序的哦，需要最后排序去重。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line">ll d[<span class="number">100</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		ll t=a%b;</span><br><span class="line">		a=b; b=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cheng</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (a%=mod;b;b&gt;&gt;=<span class="number">1</span>,a=(a+a)%mod)</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res+=a,res%=mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (a%=mod;b;b&gt;&gt;=<span class="number">1</span>,a=cheng(a,a,mod))</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res=cheng(res,a,mod);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">9</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MillerRabin</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll w=n<span class="number">-1</span>; <span class="keyword">int</span> lg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (w%<span class="number">2</span>==<span class="number">0</span>) w&gt;&gt;=<span class="number">1</span>,lg++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==prime[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ll x=ksm(prime[i],w,n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lg;j++) &#123;</span><br><span class="line">            ll y=cheng(x,x,n);</span><br><span class="line">            <span class="keyword">if</span> (x!=<span class="number">1</span>&amp;&amp;x!=n<span class="number">-1</span>&amp;&amp;y==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            x=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">PollardRho</span><span class="params">(ll n,ll c)</span> </span>&#123;</span><br><span class="line">	ll x=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>,y=x,tmp,i=<span class="number">1</span>,k=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		i++;</span><br><span class="line">		x=cheng(x,x,n)+c; x%=n;</span><br><span class="line">		tmp=gcd(y-x,n);</span><br><span class="line">		<span class="keyword">if</span> (tmp&gt;<span class="number">1</span>&amp;&amp;tmp&lt;n) <span class="keyword">return</span> tmp;</span><br><span class="line">		<span class="keyword">if</span> (x==y) <span class="keyword">return</span> n;</span><br><span class="line">		<span class="keyword">if</span> (i==k) y=x,k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (MillerRabin(n)) &#123; d[++cnt]=n; <span class="keyword">return</span>; &#125;</span><br><span class="line">    ll tmp=n;</span><br><span class="line">    <span class="keyword">while</span> (tmp==n) tmp=PollardRho(tmp,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">find</span>(tmp);</span><br><span class="line">    <span class="built_in">find</span>(n/tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2020 Open Platinum T2 Exercise</title>
    <url>/2020/04/06/USACO%202020%20Open%20Platinum%20T2/</url>
    <content><![CDATA[<p>先来看题目名称和背景相同的 Gold T3（这次 Gold 似乎没有防 AK 题？）</p>
<p>链接：<a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=1043" target="_blank" rel="noopener">http://usaco.org/index.php?page=viewproblem2&amp;cpid=1043</a></p>
<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>众所周知，permutation 会构成若干个环。在 $1$ 到 $n$ 上各站 $1$ 个人，同时开始沿着各自的环走，每次走一步。记 $K$ 为所有人都回到各自起点的最小步数，求所有可能的 $K$ 之和，对 $M$ 取模。</p>
<a id="more"></a>
<p>范围：$1 \le n \le 10^4，10^8 \le M \le 10^9+7$</p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>显然 $K$ 是所有环长的 LCM，那什么样的 $K$ 是可能的？先分解质因数：$K=\prod_{i=1}^m p_i^{\alpha_i}$，我们希望找到合适的构造。只要环长之和最小可能值 $\le n$，不足的用 $1$ 补上，即要求 $\sum_{i=1}^m p_i^{\alpha_i}\le n$。</p>
<p>预处理出 $1…n$ 的所有质数，大约 1000 个左右，而 $\alpha_i$ 的最大可能值随着 $p_i$ 的增长迅速下降，这说明直接 DP 复杂度没问题。设 $dp[j][s]$ 表示考虑前 $j$ 个质数，$\sum_{i=1}^j p_i^{\alpha_i}=s$ 的方案数。转移时枚举 $\alpha_j$ 即可，注意 $\alpha_j=0$ 时不计入 $s$（因为根本没出现）也可以通过调试样例发现这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123; (t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>; ch=getchar(); &#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n,tmp,dp[<span class="number">1510</span>][maxn],ans;</span><br><span class="line">ll mod;</span><br><span class="line"><span class="keyword">int</span> prime[maxn],tot,b[maxn],mi[maxn][<span class="number">50</span>],t;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x+=y; <span class="keyword">if</span> (x&gt;=mod) x-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"exercise.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"exercise.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(mod);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			prime[++tot]=i;</span><br><span class="line">			tmp=i; b[tot]=<span class="number">1</span>;</span><br><span class="line">			mi[tot][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">			mi[tot][<span class="number">1</span>]=i;</span><br><span class="line">			<span class="keyword">while</span> (tmp&lt;=n/i) tmp*=i,b[tot]++,mi[tot][b[tot]]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">			tmp=prime[j]*i;</span><br><span class="line">			<span class="keyword">if</span> (tmp&gt;n) <span class="keyword">break</span>;</span><br><span class="line">			vis[tmp]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=n;s++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dp[i][s]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=b[i+<span class="number">1</span>];j++) &#123;</span><br><span class="line">			t=s+mi[i+<span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (!j) t--;</span><br><span class="line">			<span class="keyword">if</span> (t&gt;n) <span class="keyword">break</span>;</span><br><span class="line">			update(dp[i+<span class="number">1</span>][t],(ll)dp[i][s]*mi[i+<span class="number">1</span>][j]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=n;s++) update(ans,dp[tot][s]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0. Enough array size? Enough array size? Enough array size? Interger overflow?</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  1. Think TWICE, Code ONCE!</span></span><br><span class="line"><span class="comment">  Are there any counterexamples to your algo?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  2. Be careful about the BOUNDARIES!</span></span><br><span class="line"><span class="comment">  N=1? P=1? Something about 0?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  3. Do not make STUPID MISTAKES!</span></span><br><span class="line"><span class="comment">  Time complexity? Memory usage? Precision error?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>链接：<a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=1045" target="_blank" rel="noopener">http://usaco.org/index.php?page=viewproblem2&amp;cpid=1045</a></p>
<h6 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h6><p>进阶版：求 $n!$ 个 permutation 对应 $K$ 的乘积，对 $M$ 取模，$1\le n \le 7500$。</p>
<h6 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h6><p>不是所有可能的 $K$ 之积，而是所有 permutation 的 $K$ 之积。我们需要从固定环长、计算 permutation 个数的角度考虑。</p>
<p>第一步转化：枚举 $p_i$，计算 $\sum \alpha_i \pmod {M-1}$，也可以模 $\varphi(M)$。这是样例解释给我们的提示。</p>
<p>如果再枚举 $\alpha_i$，会发现并不好控制 $\nu_{p_i}(K)=\alpha_i$，可能会超过。这启示我们用容斥，强制 $t$ 个环长是 $p_i^{\alpha_i}$ 的倍数，再乘上 $(-1)^{t+1}$ 计入贡献。</p>
<p>设 $dp[i]$ 表示当前强制环长之和为 $i\cdot p^{\alpha}$ 的贡献，则 $dp[0]=-1$。</p>
<p>转移时枚举最后一个环长 $j\cdot p^{\alpha}$，为了避免重复，假设当前编号为 $1$ 到 $i\cdot p^{\alpha}$，强制 $1$ 在 $j\cdot p^{\alpha}$ 这个环上。系数就是选出这些编号 $\times$ 环排列个数。</p>
<script type="math/tex; mode=display">
dp[i]= \sum_{j=1}^i -dp[i-j] \binom{i\cdot p^{\alpha}-1}{j\cdot p^{\alpha}-1}(j\cdot p^{\alpha}-1)!</script><p>别忘了除了强制以外，是可以随便排的。</p>
<script type="math/tex; mode=display">
res= \sum_{i=1}^n dp[i] \binom n{i\cdot p^{\alpha}}(n-i\cdot p^{\alpha})!</script><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123; (t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>; ch=getchar(); &#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">7510</span>;</span><br><span class="line"><span class="keyword">int</span> n,C[maxn][maxn],dp[maxn],tmp;</span><br><span class="line">ll mod,ans,jc[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn],tot,b[maxn],mi[maxn][<span class="number">50</span>],t;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x+=y; <span class="keyword">if</span> (x&gt;=mod) x-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y&amp;<span class="number">1</span>) res=(ll)res*x%(mod+<span class="number">1</span>);</span><br><span class="line">		x=(ll)x*x%(mod+<span class="number">1</span>); y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>]=mod<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/s;i++) &#123;</span><br><span class="line">		dp[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			update(dp[i],mod-(ll)dp[i-j]*C[i*s<span class="number">-1</span>][j*s<span class="number">-1</span>]%mod*jc[j*s<span class="number">-1</span>]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		update(res,(ll)dp[i]*C[n][i*s]%mod*jc[n-i*s]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"exercise.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"exercise.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="built_in">read</span>(mod);</span><br><span class="line">	mod--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">			C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			prime[++tot]=i;</span><br><span class="line">			tmp=i; b[tot]=<span class="number">1</span>;</span><br><span class="line">			mi[tot][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">			mi[tot][<span class="number">1</span>]=i;</span><br><span class="line">			<span class="keyword">while</span> (tmp&lt;=n/i) tmp*=i,b[tot]++,mi[tot][b[tot]]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) &#123;</span><br><span class="line">			tmp=prime[j]*i;</span><br><span class="line">			<span class="keyword">if</span> (tmp&gt;n) <span class="keyword">break</span>;</span><br><span class="line">			vis[tmp]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b[i];j++) &#123;</span><br><span class="line">		ans*=ksm(prime[i],solve(mi[i][j]));</span><br><span class="line">		ans%=mod+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0. Enough array size? Enough array size? Enough array size? Interger overflow?</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  1. Think TWICE, Code ONCE!</span></span><br><span class="line"><span class="comment">  Are there any counterexamples to your algo?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  2. Be careful about the BOUNDARIES!</span></span><br><span class="line"><span class="comment">  N=1? P=1? Something about 0?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  3. Do not make STUPID MISTAKES!</span></span><br><span class="line"><span class="comment">  Time complexity? Memory usage? Precision error?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2020 Open Platinum T3 Circus</title>
    <url>/2020/04/06/USACO%202020%20Open%20Platinum%20T3/</url>
    <content><![CDATA[<p>链接：<a href="http://usaco.org/index.php?page=viewproblem2&amp;cpid=1046" target="_blank" rel="noopener">http://usaco.org/index.php?page=viewproblem2&amp;cpid=1046</a></p>
<h6 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h6><p>一棵 $n$ 个节点的树上有 $K$ 头奶牛，它们可以任意移动，但不能碰到其他奶牛。如果从一个状态经过有限次移动能到达另一个状态，则称它们属于同一个等价类（可达）。奶牛是编号的，对 $K=1,2, \ldots n$ 输出等价类个数，对 $10^9+7$ 取模。</p>
<a id="more"></a>
<p>范围：$1 \le n \le 10^5$。</p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>首先证明，如果不考虑奶牛编号的问题，所有状态均互相可达。将 dfs 序定义为递归完子树退出时的序号，考虑 dfs 序前 $K$ 小的节点 $u_1,u_2, \ldots ,u_K$。设奶牛所在的点按到 $u_1$ 的距离从小到大依次为 $v_1,v_2, \ldots ,v_K$，我们想办法把 $v_1$ 挪到 $u_1$，这样就能归纳了（$u_1$ 一定是叶子，去掉后还是树）。显然 $v_1$ 到 $u_1$ 的路径上不会有其他奶牛，因而得证。</p>
<p>这样一来，我们只要钦定 $K$ 个点，计算 $K!$ 种编号的等价类个数就好了。而两个状态互相可达的过程，可以分解成每次交换两个点。如果某两个点可以顺利交换位置，就在一张想象的新图中合并起来。设新图中连通块大小为 $s_1,s_2, \ldots s_m$，那么等价类个数就是 $\frac {K!}{\prod_{i=1}^m s_i!}$，相比较原问题已经有很大的进步。</p>
<p>另一个观察是，可用于交换两点的中转站度数 $\ge 3$，所以我们取一个这样的节点作为根。若不存在，说明是条链，压根没法交换，直接输出 $K!$ 就好了。此外，$K=n-1$ 或 $n$ 时答案总是 $K!$，因为也没法换（样例 / 写暴力主要就说明了这一点…）</p>
<p>下面考虑 $K\le n-2$ 的情况，最开始钦定的 $K$ 个点为深度前 $K$ 大的。这样的好处是它们聚集在了若干个底下的子树里，如果 $K$ 从小到大看，它们会慢慢往上长，从而方便我们维护答案。</p>
<p>新图中，需要合并哪些点？事实上，父亲-儿子，儿子-儿子，子树根-子树根，这$3$种便足够了。跨层的交换，可以用这些中间步骤代替。我们剩下要解决的，是这些合并操作在哪些 $K$ 时成立。</p>
<p>儿子-儿子：同一个父亲的$2$个儿子，在它们都被钦定后即可合并。原因在于根节点、父亲度数$\ge 3$，$K \le n-2$。</p>
<p>父亲-儿子：记 $dis(u)$ 表示 $u$ 子树外所有度数 $\ge 3$ 的点到 $u$ 的最短距离（经过边），用 $2$ 遍 dfs + 前后缀 mn 可解决（具体见代码）那么如果 $K+dis(父亲)\le n-2$ 且父亲被钦定，即可合并。原因在于至少要空出这 $dis(父亲)$ 个节点，之前也证明了只要其余节点不计编号、没那么多，一定可以顺利让出来。</p>
<p>子树根-子树根：当 $K&lt;n-2$ 时，任何两个子树根都可跑到根节点处交换；当 $K=n-2$ 时，只空出了根节点+它的一个儿子，分$2$种情况：（方框为钦定的节点）</p>
<p><img src="\graph\3.png" alt="image" style="zoom:50%;" /></p>
<p>我们会发现，此时只有深度相同的子树根之间能互相交换，这样只要对 $K=n-2$ 最后重新做一遍特判即可。可以对子树根单独开一两个节点用来搞定连通性，当然不开也能做。</p>
<p>一般的合并操作，只在 $K$ 处于一个区间时有效，用线段树+可撤销并查集就能维护答案了，时间复杂度 $\mathcal O(n\log ^2n)​$。这个“黑科技”真是既好用又好写！</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p><del>官方题解一个log但我没看懂</del></p>
<p>看起来很长是因为套了很多东西；只跑了不到 600ms 呢</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">	t=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar(); <span class="keyword">int</span> f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123; <span class="keyword">if</span> (ch==<span class="string">'-'</span>) f=<span class="number">-1</span>; ch=getchar(); &#125;</span><br><span class="line">	<span class="keyword">do</span> &#123; (t*=<span class="number">10</span>)+=ch-<span class="string">'0'</span>; ch=getchar(); &#125; <span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch&amp;&amp;ch&lt;=<span class="string">'9'</span>); t*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=(<span class="number">1e9</span>)+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">1e5</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=(<span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">int</span> n,rt,head[maxn],nxt[maxn*<span class="number">2</span>],to[maxn*<span class="number">2</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; tot++; nxt[tot]=head[x]; head[x]=tot; to[tot]=y; &#125;</span><br><span class="line"><span class="keyword">int</span> iv[maxn],jc[maxn],ivjc[maxn],ans[maxn],deg[maxn],rk[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn],sz[maxn],d[maxn],dep[maxn],bg[maxn],ed[maxn];</span><br><span class="line"><span class="keyword">int</span> mn[maxn],dis[maxn],sum,f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[x]==dep[y]) <span class="keyword">return</span> x&lt;y;</span><br><span class="line">	<span class="keyword">return</span> dep[x]&gt;dep[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> x,y; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; g[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node2</span> &#123;</span> <span class="keyword">int</span> x,y,l,r; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node2&gt; edge;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root,Node A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L&gt;R) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">		g[root].push_back(A);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (L&lt;=mid) add(L,R,l,mid,root*<span class="number">2</span>,A);</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;R) add(L,R,mid+<span class="number">1</span>,r,root*<span class="number">2</span>+<span class="number">1</span>,A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="keyword">int</span> x,y,szy,fax,s; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x=<span class="built_in">find</span>(x); y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x==y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (sz[x]&gt;sz[y]) swap(x,y);</span><br><span class="line">	st.push_back((node)&#123;x,y,sz[y],fa[x],sum&#125;);</span><br><span class="line">	sum=(ll)sum*jc[sz[y]]%mod*jc[sz[x]]%mod;</span><br><span class="line">	sz[y]+=sz[x]; fa[x]=y;</span><br><span class="line">	sum=(ll)sum*ivjc[sz[y]]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">roll</span><span class="params">(node A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=A.x,y=A.y;</span><br><span class="line">	fa[x]=A.fax,sz[y]=A.szy;</span><br><span class="line">	sum=A.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp=st.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[root].<span class="built_in">size</span>();i++) merge(g[root][i].x,g[root][i].y);</span><br><span class="line">	<span class="keyword">if</span> (l==r) &#123;</span><br><span class="line">		ans[l]=(ll)sum*jc[l]%mod;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		solve(l,mid,root*<span class="number">2</span>);</span><br><span class="line">		solve(mid+<span class="number">1</span>,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (st.<span class="built_in">size</span>()&gt;tmp) &#123;</span><br><span class="line">		roll(st.back()),st.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	bg[u]=++tot; dep[u]=dep[p]+<span class="number">1</span>;</span><br><span class="line">	f[u]=p;</span><br><span class="line">	mn[u]=dis[u]=INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[u],v;i;i=nxt[i]) &#123;</span><br><span class="line">		v=to[i];</span><br><span class="line">		<span class="keyword">if</span> (v==p) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">		mn[u]=<span class="built_in">min</span>(mn[u],mn[v]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ed[u]=tot;</span><br><span class="line">	<span class="keyword">if</span> (deg[u]&gt;<span class="number">2</span>) mn[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; N[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp=dis[u]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (deg[u]&gt;<span class="number">2</span>) tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=head[u],v;i;i=nxt[i]) &#123;</span><br><span class="line">		v=to[i];</span><br><span class="line">		<span class="keyword">if</span> (v==f[u]) <span class="keyword">continue</span>;</span><br><span class="line">		dis[v]=<span class="built_in">min</span>(dis[v],tmp);</span><br><span class="line">		tmp=<span class="built_in">min</span>(tmp,mn[v]+<span class="number">2</span>);</span><br><span class="line">		N[u].push_back(v);</span><br><span class="line">	&#125;</span><br><span class="line">	tmp=dis[u]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (deg[u]&gt;<span class="number">2</span>) tmp=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=N[u].<span class="built_in">size</span>()<span class="number">-1</span>,v;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		v=N[u][i];</span><br><span class="line">		dis[v]=<span class="built_in">min</span>(dis[v],tmp);</span><br><span class="line">		tmp=<span class="built_in">min</span>(tmp,mn[v]+<span class="number">2</span>);</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y,lst;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		x=d[i];</span><br><span class="line">		<span class="keyword">if</span> (rk[x]&gt;n<span class="number">-2</span>) <span class="keyword">continue</span>;</span><br><span class="line">		lst=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=head[x];j;j=nxt[j]) &#123;</span><br><span class="line">			y=to[j];</span><br><span class="line">			<span class="keyword">if</span> (y==f[x]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (lst) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!flag) add(<span class="built_in">max</span>(rk[lst],rk[y]),n<span class="number">-2</span>,<span class="number">1</span>,n<span class="number">-2</span>,<span class="number">1</span>,(Node)&#123;y,lst&#125;);</span><br><span class="line">				<span class="keyword">else</span> edge.push_back((node2)&#123;y,lst,<span class="built_in">max</span>(rk[lst],rk[y]),n<span class="number">-2</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			lst=y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (lst) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag) add(rk[x],n<span class="number">-2</span>-dis[x],<span class="number">1</span>,n<span class="number">-2</span>,<span class="number">1</span>,(Node)&#123;lst,x&#125;);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (rk[x]&lt;=n<span class="number">-2</span>-dis[x]) edge.push_back((node2)&#123;lst,x,rk[x],n<span class="number">-2</span>-dis[x]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			add(rk[x],<span class="built_in">min</span>(n<span class="number">-2</span>,rk[f[x]]<span class="number">-1</span>),<span class="number">1</span>,n<span class="number">-2</span>,<span class="number">1</span>,(Node)&#123;n+<span class="number">1</span>,x&#125;);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rk[f[x]]&gt;n<span class="number">-2</span>) &#123;</span><br><span class="line">			edge.push_back((node2)&#123;n+dep[x]<span class="number">-1</span>,x,rk[x],n<span class="number">-2</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"circus.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"circus.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">read</span>(n); <span class="keyword">int</span> x,y;</span><br><span class="line">	jc[<span class="number">0</span>]=jc[<span class="number">1</span>]=iv[<span class="number">0</span>]=iv[<span class="number">1</span>]=ivjc[<span class="number">0</span>]=ivjc[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) jc[i]=(ll)jc[i<span class="number">-1</span>]*i%mod,iv[i]=(ll)(mod-mod/i)*iv[mod%i]%mod,ivjc[i]=(ll)ivjc[i<span class="number">-1</span>]*iv[i]%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">read</span>(x); <span class="built_in">read</span>(y);</span><br><span class="line">		add(x,y); add(y,x);</span><br><span class="line">		deg[x]++; deg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (deg[i]&gt;<span class="number">2</span>) &#123; rt=i; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,jc[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(rt,<span class="number">0</span>);</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	dfs(rt);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i]=i;</span><br><span class="line">	sort(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[d[i]]=i;</span><br><span class="line">	build(<span class="number">0</span>);</span><br><span class="line">	sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line">	fa[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">	solve(<span class="number">1</span>,n<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line">	sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line">	fa[n+<span class="number">1</span>]=n+<span class="number">1</span>; fa[n+<span class="number">2</span>]=n+<span class="number">2</span>;</span><br><span class="line">	build(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		x=edge[i].x,y=edge[i].y;</span><br><span class="line">		<span class="keyword">if</span> (edge[i].l&lt;=n<span class="number">-2</span>&amp;&amp;n<span class="number">-2</span>&lt;=edge[i].r) &#123;</span><br><span class="line">			merge(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[n<span class="number">-2</span>]=(ll)sum*jc[n<span class="number">-2</span>]%mod;</span><br><span class="line">	ans[n<span class="number">-1</span>]=jc[n<span class="number">-1</span>];</span><br><span class="line">	ans[n]=jc[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  0. Enough array size? Enough array size? Enough array size? Interger overflow?</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  1. Think TWICE, Code ONCE!</span></span><br><span class="line"><span class="comment">  Are there any counterexamples to your algo?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  2. Be careful about the BOUNDARIES!</span></span><br><span class="line"><span class="comment">  N=1? P=1? Something about 0?</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  3. Do not make STUPID MISTAKES!</span></span><br><span class="line"><span class="comment">  Time complexity? Memory usage? Precision error?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>WC 2019 - I 君的商店 85pts</title>
    <url>/2019/02/10/WC%202019%20-%20I%20%E5%90%9B%E7%9A%84%E5%95%86%E5%BA%97/</url>
    <content><![CDATA[<p>题目来源：<a href="https://loj.ac/problem/2985" target="_blank" rel="noopener">https://loj.ac/problem/2985</a></p>
<a id="more"></a>
<h5 id="子任务-3"><a href="#子任务-3" class="headerlink" title="子任务 3"></a>子任务 3</h5><p>保证 $ans$ 有序，首先通过询问 $\{0\}$ 和 $\{n-1\}$ 判断序列是 0…01…1 还是 1…10…0，不妨假设为前者。</p>
<p>接着二分 01 断点位置，通过奇偶性 K 确定二分的集合，每次比较 $\{mid-1,mid\}$ 和 $\{n-1\}$。由于 K 一定合法，则 $mid-1$ 与 $mid$ 必然相同，比较结果即表明 $mid$ 是 0 还是 1。如果二分不到答案，说明 $ans$ 全为 1，同理解决 1…10…0 的情况。</p>
<h5 id="子任务-1-2-4-5"><a href="#子任务-1-2-4-5" class="headerlink" title="子任务 1,2,4,5"></a>子任务 1,2,4,5</h5><p>用扫一遍找 max 的方法 $O(2n)$ 询问出 1 的位置 $a$（一定存在），然后通过维护 $queue$ 的方式每次找两个还未确定 $ans$ 的位置 $x$ 和 $y$，并询问 $\{a\}$ 和 $\{x,y\}$。如果 $a\leq x+y$，则 $x$ 和 $y$ 不可能全 0 $\Rightarrow$ 有 1；如果 $a\geq x+y$，则 $x$ 和 $y$ 不可能全 1 $\Rightarrow$ 有 0。再询问 $\{x\}$ 和 $\{y\}$ 就能确定其中一个了，总共花费 $O(7n)$ 即可确定所有值啦。（最后剩下的那个用 <strong>K</strong> 算一下）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shop.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">1e6</span>);</span><br><span class="line"><span class="keyword">int</span> S[<span class="number">10</span>],T[<span class="number">10</span>],cnt,tot;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_price</span><span class="params">(<span class="keyword">int</span> task_id, <span class="keyword">int</span> n, <span class="keyword">int</span> K, <span class="keyword">int</span> ans[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>) &#123; ans[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (task_id==<span class="number">3</span>) &#123;</span><br><span class="line">		S[<span class="number">0</span>]=<span class="number">0</span>; T[<span class="number">0</span>]=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> l,r,mid,res=<span class="number">-1</span>; tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">				<span class="keyword">if</span> (((n-i<span class="number">-1</span>)&amp;<span class="number">1</span>)==K) d[++tot]=i;</span><br><span class="line">			l=<span class="number">1</span>,r=tot;</span><br><span class="line">			<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">				mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				S[<span class="number">0</span>]=d[mid]<span class="number">-1</span>; S[<span class="number">1</span>]=d[mid]; T[<span class="number">0</span>]=n<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">2</span>,T,<span class="number">1</span>)) res=d[mid],l=mid+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n&amp;<span class="number">1</span>)!=K) res=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res;i++) ans[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=res+<span class="number">1</span>;i&lt;n;i++) ans[i]=<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">				<span class="keyword">if</span> ((i&amp;<span class="number">1</span>)==K) d[++tot]=i;</span><br><span class="line">			l=<span class="number">1</span>,r=tot;</span><br><span class="line">			<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">				mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				S[<span class="number">0</span>]=d[mid]; S[<span class="number">1</span>]=d[mid]+<span class="number">1</span>; T[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">2</span>,T,<span class="number">1</span>)) res=d[mid],r=mid<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n&amp;<span class="number">1</span>)!=K) res=n<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> res=n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res;i++) ans[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=res;i&lt;n;i++) ans[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	S[<span class="number">0</span>]=<span class="number">0</span>; T[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> a=query(S,<span class="number">1</span>,T,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">		S[<span class="number">0</span>]=a; T[<span class="number">0</span>]=i;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) a=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="number">-1</span>;</span><br><span class="line">	ans[a]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">if</span> (i!=a) q.push(i);</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">		<span class="keyword">int</span> y=q.front(); q.pop();</span><br><span class="line">		S[<span class="number">0</span>]=a; T[<span class="number">0</span>]=x; T[<span class="number">1</span>]=y;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">2</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">			S[<span class="number">0</span>]=x; T[<span class="number">0</span>]=y;</span><br><span class="line">			<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">				ans[y]=<span class="number">0</span>; q.push(x);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; ans[x]=<span class="number">0</span>; q.push(y); &#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			S[<span class="number">0</span>]=x; T[<span class="number">0</span>]=y;</span><br><span class="line">			<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">				ans[x]=<span class="number">1</span>; cnt++; q.push(y);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; ans[y]=<span class="number">1</span>; cnt++; q.push(x); &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) a=q.front(),q.pop();</span><br><span class="line">	ans[a]=(K-cnt&amp;<span class="number">1</span>+<span class="number">4</span>)%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附 AC 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shop.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=(<span class="number">1e6</span>);</span><br><span class="line"><span class="keyword">int</span> S[<span class="number">10</span>],T[<span class="number">10</span>],cnt,tot;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_price</span><span class="params">(<span class="keyword">int</span> task_id, <span class="keyword">int</span> n, <span class="keyword">int</span> K, <span class="keyword">int</span> ans[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>) &#123; ans[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (task_id==<span class="number">3</span>) &#123;</span><br><span class="line">		S[<span class="number">0</span>]=<span class="number">0</span>; T[<span class="number">0</span>]=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> l,r,mid,res=<span class="number">-1</span>; tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">				<span class="keyword">if</span> (((n-i<span class="number">-1</span>)&amp;<span class="number">1</span>)==K) d[++tot]=i;</span><br><span class="line">			l=<span class="number">1</span>,r=tot;</span><br><span class="line">			<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">				mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				S[<span class="number">0</span>]=d[mid]<span class="number">-1</span>; S[<span class="number">1</span>]=d[mid]; T[<span class="number">0</span>]=n<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">2</span>,T,<span class="number">1</span>)) res=d[mid],l=mid+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n&amp;<span class="number">1</span>)!=K) res=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res;i++) ans[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=res+<span class="number">1</span>;i&lt;n;i++) ans[i]=<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">				<span class="keyword">if</span> ((i&amp;<span class="number">1</span>)==K) d[++tot]=i;</span><br><span class="line">			l=<span class="number">1</span>,r=tot;</span><br><span class="line">			<span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">				mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				S[<span class="number">0</span>]=d[mid]; S[<span class="number">1</span>]=d[mid]+<span class="number">1</span>; T[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">2</span>,T,<span class="number">1</span>)) res=d[mid],r=mid<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res==<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n&amp;<span class="number">1</span>)!=K) res=n<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> res=n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res;i++) ans[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i=res;i&lt;n;i++) ans[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (task_id&lt;<span class="number">6</span>) &#123;</span><br><span class="line">		S[<span class="number">0</span>]=<span class="number">0</span>; T[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> a=query(S,<span class="number">1</span>,T,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">			S[<span class="number">0</span>]=a; T[<span class="number">0</span>]=i;</span><br><span class="line">			<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) a=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="number">-1</span>;</span><br><span class="line">		ans[a]=<span class="number">1</span>; cnt=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span> (i!=a) q.push(i);</span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x=q.front(); q.pop();</span><br><span class="line">			<span class="keyword">int</span> y=q.front(); q.pop();</span><br><span class="line">			S[<span class="number">0</span>]=a; T[<span class="number">0</span>]=x; T[<span class="number">1</span>]=y;</span><br><span class="line">			<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">2</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">				S[<span class="number">0</span>]=x; T[<span class="number">0</span>]=y;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">					ans[y]=<span class="number">0</span>; q.push(x);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; ans[x]=<span class="number">0</span>; q.push(y); &#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				S[<span class="number">0</span>]=x; T[<span class="number">0</span>]=y;</span><br><span class="line">				<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">					ans[x]=<span class="number">1</span>; cnt++; q.push(y);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; ans[y]=<span class="number">1</span>; cnt++; q.push(x); &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) a=q.front(),q.pop();</span><br><span class="line">		ans[a]=(K-cnt&amp;<span class="number">1</span>+<span class="number">4</span>)%<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">1</span>,x=<span class="number">2</span>,y=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		S[<span class="number">0</span>]=x<span class="number">-1</span>,T[<span class="number">0</span>]=y<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) swap(x,y);</span><br><span class="line">		S[<span class="number">0</span>]=a<span class="number">-1</span>,T[<span class="number">0</span>]=x<span class="number">-1</span>,T[<span class="number">1</span>]=y<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!query(S,<span class="number">1</span>,T,<span class="number">2</span>)) ans[y]=<span class="number">0</span>,y=i;</span><br><span class="line">		<span class="keyword">else</span> d[++tot]=a,a=x,x=i;</span><br><span class="line">	&#125;</span><br><span class="line">	d[++tot]=a;</span><br><span class="line">	x=<span class="built_in">min</span>(x,y);</span><br><span class="line">	S[<span class="number">0</span>]=a<span class="number">-1</span>,T[<span class="number">0</span>]=x<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) d[++tot]=x,x=<span class="number">0</span>;</span><br><span class="line">	reverse(d+<span class="number">1</span>,d+tot+<span class="number">1</span>);</span><br><span class="line">	ans[d[<span class="number">1</span>]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">2</span>,r=tot,mid;</span><br><span class="line">	<span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		S[<span class="number">0</span>]=d[mid]<span class="number">-1</span>; S[<span class="number">1</span>]=d[mid+<span class="number">1</span>]<span class="number">-1</span>; T[<span class="number">0</span>]=d[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!query(T,<span class="number">1</span>,S,<span class="number">2</span>)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!x) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((l&amp;<span class="number">1</span>)!=K) l--;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mn,mx,delta=<span class="number">0</span>;</span><br><span class="line">		S[<span class="number">0</span>]=x<span class="number">-1</span>,T[<span class="number">0</span>]=d[l]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (query(S,<span class="number">1</span>,T,<span class="number">1</span>)) mn=x,mx=d[l];</span><br><span class="line">		<span class="keyword">else</span> mn=d[l],mx=x;</span><br><span class="line">		S[<span class="number">0</span>]=d[<span class="number">1</span>]<span class="number">-1</span>,T[<span class="number">0</span>]=x<span class="number">-1</span>,T[<span class="number">1</span>]=d[l]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!query(S,<span class="number">1</span>,T,<span class="number">2</span>)) ans[mn<span class="number">-1</span>]=<span class="number">0</span>,d[l]=mx;</span><br><span class="line">		<span class="keyword">else</span> ans[mx<span class="number">-1</span>]=<span class="number">1</span>,d[l]=mn,delta=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (((l+delta)&amp;<span class="number">1</span>)!=K) l--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++) ans[d[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=l+<span class="number">1</span>;i&lt;=tot;i++) ans[d[i]<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WC</category>
      </categories>
      <tags>
        <tag>Parity</tag>
        <tag>交互</tag>
        <tag>构造</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数笔记</title>
    <url>/2019/01/05/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="1d4ef741ab6a203fb7971ba07c9e0d567c96f65efc9e81d30f07f969c3476afb">109963fecf4b3bfe9afd6a39877b031c00d882e74685b2c86673be5db159be9144c9d7efaf045869c9a0bb64c5783751b3c858a5e4091335d5a04c73cce352c651a6c8a5fd24879c972cc9a3478fe91f95ef773ccfc00725d9b24f383ac789a06acd2a3e848f20a016144472cb6a4408567c21f8b9921db5bfae4876c887cede5d983a096fd2b01156defd8306a8fdd8f99b2dd6f75abfd3a85f5d60d91a8265cf68e2668610b47f6d8da578b7449bda9ca8e773c48f70cbd533a9c21d387ed0933cc22398302069b64f718fd57f5ad6c9674547ad829f7486d1270217d97dfd00d5ab70873cc18b9adaaa2158924f88963ad963b47cd0af45754f76e76c1a91c87360d103dcafef0f02908090fdb4584de7bf46037169a7285f5ca54a8a09de2d975090e39858fa34f4bdcc4beb633cb130d46c82b8568f968c527697873233c65138d971e373c7c9ac5b9b293ae03cf5d1933d0be9b5187340042a1f444a0bd1e560ef87d3e30585e9120304e1f2a3ef18f3c344fb7b6079f26d63e4cf6fc3f31861b7b99d9bd13a9ce3a40538041c7b1899abb17ee3eb425ff89bf3cd20cf594c65e2bc2e6082bce3a3d9c499113aa972914a8c9eb28950869bad8d838ba343657869ec5c4c3098a03e30071bb38242f29839410a5118cab349d2e7625d6cdd5c04049f22e6b7abdaaf809cdcf80ebf03bb5a2717774d9169ed2524cf222c86540efacf290a703bc5bdaa6aba39960ccfae6eecb3e0c44a0e8b985bc58db9ec1df48fa9eed6c76a97b2f3bdb6a3b7c78a8f07c6ef4f65b141266a2ecca1907d3976d713eb1f9b046bfc95df24b5ea7229a53800f07164375944f10d6186ff3781722b9e3aa38e33e6125fae526176c1555623adb80f1ee3b382e007b9588605ca583b61417b668300886696a9f380c2085a5ed4e15138a5c00881418476a6b6e589a8c3d5bb139a8821a4dcad0ca42a3ee20a0102fdb83cefce68d39b404f94b2eae23182bde81d69c02d468d039c738c8d998c98153bd4babbbd26c2164628c842c6bd3673d038fedbb8ee39812402cc2a428debb3242d985bba0535956034a33b2ec89275ea682e45c2e65547dfcd5c6ad03784874a901670302fdb0ec1c0b3ef885f74bfbf4addd804a68ed21f6286770b26fc8e4d9dc12737c00aa946f43c091f5b2dc37b36c7c605c207fbcf8d967cacba3732d0c37cd3128f71b69d9fdd4678dab2a031a5dc23ee6c562040afacb78ab763946d7219045bc90cfe75e9c02a3374eb8a25a1947168d6194ccc6bd1c00f5e52c20df0c88cc65becf5bab9ad496e246db5fa1232a8e6aecf6825245d754a295f56b274ff2b000a9059c801fb5b764a58bcd7a2a5798052be2d7feb9930b183ee18c9bf6befc1f0a7426d1b5d92586bace547aeb91b4b8d1a0b23b469c18d1790d5722c556c695bbcf2f02694fd66571bdacfcf189a9c86d229f4029cd16128c204645c58e3f77aebd3cb878aa3fa2840b8caee568645610cb9ffc3dee50df77cfbf38dbc4b25802e4df9519b7c913da0f481244b299933a5b5385acac58b34a97975ffd1df6ff4ab9a5af594c811741b162c99c5fabb68e368cca6e95cf692edd754d00fb3f55fba652181fee995ea97504b840fbda9af6d980ae7ebfb9231f7f307df5151db6ba5d5618b48ecf271d0c705b802ca8be3afae407212a6a7a88ade90769d8c2006162363d52ea94f47a8a2fc46547580e2cf84d9662493b589a55fe6b75df05463dd088bc33292f95d07878ec1842a13d54a3241aedf1998e41841abfdf3971e04661373708e18ced4a8998801a8c92099e701c55d0218dba9fa85051d716a500d15fc806b3db55bc43134b59d1321e7c9d7bf7f5cb7d11d0fb565a3b2f438f6741bedf1f6326a49dc5fd9f33c7f1d851f492e163b8a4d8c6febbca08beb1fa268562970aaf7fb54dac7e1d56c7a57a5e68b17be488c88198b0fc9b4d7c5996a50e44ed460271a09e2e1690775f84dcbfc429135c987fd8bf41cf8c85cd572708ae1c69ef5cb4d1401aed9cfca8f6087757874e5aaac20728684acd221df4be18891cc1501219733439e5dc6ce3e4600c4ccbb3b4022c310faa8d8fada71c6d3de1267eb8ad09140830eab5f04598d990fe44ddd07a7ba7029080a4dab522ea965deff30037aa46df17d6b709833c87a7826d6fd2182074cf62c0ca49c725866c3388e20d7bfcdd5e47b44c7d045fa8cb0271e760de646a5ce28f053ad9da55e5b40d4b7022b37d9d3e74b82a2f220f844f80fdeae4659b0b225233e7bdce94bc7124e7e7208c9d5e09e222529b76c3b2f7cfaaa4a9a5a519a246aba787f30977c812ae5116faea26fcce260283459aa56d0abd0909c2cadfb41dbda6b3614a4581b7b23cd2734613f718ceafd10336e0c10f7cdb714cdb79c75455f64b64f3668ec616c00437e9ce68825b85269d6d7d0624a93c9a4662d2259c66ea98e684c97394da1ce9fa01605355ea4780fd889b2235c5af0b64ab4dd5bede486eb209a37528b3df7ed222d44eb9cca446618ff80dc4ac64ae6907ec7d191182559ef1444da3f19b897810da1144d433eb3bb25b6ae12710a3f9c6457ea53c2db25480f86fb99c115c9eb316bd06de06b59ba744d6d2d13acbf7d69263d44659c76b1a54f0f2c8803b8baee43070781438de0b8e4587ca42f27fc471932e6873eaa112881cfa128265ac6f77ce6f5a1289f7ed3ae6db4cf424e78c345ce400730781fdb73f0fe62acb21360430947427d16b99651ecf625607f2629f9673f065a7a1a507ac24457782f5533e6a6d748e5d3ea4881568cb63d3f8116144b9539ad99f357836d2d91af05921077da4e80af9f151981712dff38ecbae07ac0332178a3bf52841447ba437ba27571533a7f48c09ad945a76eeb8d94836ffdb6e2951bd6a731553a8d6a8bedb53a00c12944c4aeb5d27a6a755abbaae39b8a8f84af54cb4858464afcbe1725de398bc01eeeb40a4e51cb51d33a6f3255229324c7e1fb03993645e54d4bd132d1dbed9b93877e886b04d08cc1ad81d7462e2a69c78601d936732e3aa5e3c433b6337dd85c78af4373577e5ef3a903043cccf3aa8af4b0fb7389e07830f095e1e758e34584b28e0ce39ca5236f20b486139aac863c67a1bd898c077be2bfc7c4565486a8d957fd07d5f559e94ae1bdbe468c9e9aeec88318ea325301bb4c728ac41e11de823475b63f43e5160cff967909b2fcf3b6a210beee43f34af69afbceabb5d2499847969dec486e782d82787e933f2c3d7b09d4c45a0391ba97ca20eed6da423ca7c286f21f61279eadca08c9042fe04beea4d8b9b01e92f01483cdea96435663f6424f5dce5f7858e3f5a2086295e2fad7c1aa3978cdfcd5b4a67e40bb553423418ceef49922774393ba77fff0be8cc70085059004e1092b891e6db663113c1929155a8db2486bde9e8f2fc88b47f21d2c1db7ad12f79051cb33c147d99a865d2c8ad1adc5c663c5ed6ce0a0ef8bca46cd6efd3454dd58fcc7a44c3460f1c0465839582c1a07f80d0a0219f0add02f6701ce9c4b07343870fc0fded60612ff80a52c304898738ef3efa647c914a6599739f0d05e20b45efdbbb7375ee4900d6622a5db13bcb02a421370ce4cbe982f0d0b2d79fdb041972b0c131589a3363aa8b64254174f3e207b17feeb1a43f4305d8dcabfdfdb7719f831232de2e28da0d32194ca51533e13023bd8b1251213a8edb711699b738b7e622988eea02b35404bf1f1a58c0351d7822f12cb77f8413adbd61d40cf5e9e1b75dd7c3dbbdd342900721c48c50b8f35e4d2f2656744450a38d19576eccac09f3eedec68823940e04925bbd385cec3a35e7e20443b0db33e92144cb082b1277f9b06c529295d93e0469b45bb4eb08224ebb00c3bff26cbd706bcd8a848766e5129bb3080ce9b7f274365f8e957da07b2f10ecec8f28820c5d682b58590c3ac57b657457c1407ce6da2491889af52fcd88930f9d5ea6c71064daa3e75c8f20f113744e8c8182f185d895723b482e934ef22655e77fb9832d55310cf5dfab18f92bb073a5179537af73621572e871f0dddf95ee5ee614324b187fd7db725b27cbd2e156c3049809da8ee74c6e681a140413f6d87ddeed7b97f383b2923804765d93cbef7ebf3ac728d9038cd1b70fa731fe141363405ebeaaa13f526ee212f1beed3a332bbfb4e8767f95a80d98d93e11dcfb16bd0541518df6588642f40ecb14af7e994be07dcc83673768eae340ad95ebf082345a3b3e9d48b4bb5fe88ba6f5150ac91efbda496dc0f10645600760ad3bca218e72f2e4ab7a64dc7ba15d02558570377be141614739c9b1c8511e35a7713b614e8082b490e35c5634293f0c11fd48b2553a6cf2f05ea40538af007723c032d77c1379cfc55a23739623533b68d5148c957628145b9329dce70b02262c492e288d3f702c56fe512a29bf6169334013e382043bd91a21ce7aa147e35a09487178d20f582663ffdb3cd6a53c1850969013a59dc6bfc4f141af981c09d5a2ae1a7b44e0cc1060c1266acad1c52c115b5e6d8bca1f84a44087a847830a9798db02cea67898d276df799acf08255972c09ced8c910d04ff72220039c2cf9e0cb08466e32ce13a86848faa608952569e124687cef0539e18eb2509c09ad3371fda8bc2e57893e358b387b9887bb6355851d75c09e56b6746081cb956cb74ffca8c13414898ff43cf1efaf35719e991be98a13a7561aa4ad02af40dd52055a5899aa3711a25aa3cc0d13c623dee526d60d91dc979d220bb0913598831838c5f254a5fffe5ffd4eb2f562027f83516e33a679deec362c03a64714689651d115c76a78a882f77d98e9c94edfa95102606eb19578c1b23acf0f2efc34b3f5f93ae493dd087715ef587d5bc1827655ddbdc6317d20c597b5a79a920659df10a616219071d61aa80be9f84e8c67643e81ea2646823eae0448276ad9db2ba59cff0050bb7df5d96da752572fc62633d273331a93876704d0ed27b0457f314610853cf92dd773487a9b87d55e9bc57849bd1708f3ca9684964dd4966086fa9799b278025c0521f6b3590f8f74bbd4e0b16c2eed0070e97b02a4c1122dc3b89f1ddc7ae27dadec6e5f1f726e3ca2bf9ad227bebe0767a70ed21bf8cd7b7a78b97e45e145f826bc71742d2700bb1c88df124699cef643cd961abbb8268ffca0a770a33f8002c831148752bfbd1ed602d6d8fa0a52521b8582f25569cd3e7ab6c4779c83f121f579f02bc95679da7b89a43f6affb72dff816575d567163323c62671c18cb4049f1e941bd92889081801da998e8c00cefd11e81feb44d48f8fe37e3eb14ac36d2753366188935fc4bd15d504c1078c55eed00ac3ba86128a9f5bcdb6c19a898fbea0da0786079ff81847eb80a691ef2c3526d90f144d5212e56a65b0bddf3e1021a8fb96c38c2e0194cd2315639a629d60175715bbfef5cd9d1d961bb32cef531e7f61bbcc14641ea973b9b87144005fc4351ba8064d4e48a683ddcb57606b9d38bfb935fb11bd40dad9e05a6872f8782a5cd94f99eac55cf1a21f7843e86b282df61bfdaaac274de3ee9a20491fc11971156a0793b09d7441dd39fccaeab42d2c83edc3a02d75183019b37707b99c9f9703164af7838e15f47b95e72470fb6be1f60caae0b2fc808842a7c6b503791ec2773d9efa8a6973e52b69b34ec1c93b934f39c090d58dda2ccae0f8df3803622352ee12f2084a2d788eb23a48b042ae2773ab50384fdeb856fbafd72fca2a6c5c4bbaf5aca3944ecd19a14cb118a6f5f19e35b78273dd772b3ae1a103f230a27f2fbb196103fdcc6414a7f4eb19792dd3a43d021f060a237d8f5e37b75ab069db3e436130714cda8f979d7b07bdaf79c5259957bb7e828142ff97e2bf655c73495a9881efa64d96635811b5d6aa645bee77a75c4784c10e29ae9edf9cf792294471e6098b75ba27d4e5c5e08326aa3a5a3165f0579d3d8df935bd3bdece3d68f35cd7525d2d1ccaa1d06412c6593d95baa26019f69db7419e2096177d30b29f24cb0dc53bfbd328cabefc1b940280c17275641f469e83614322a540b68125e2f7a78f2dbc18fe88cad5acda76dcd736d299ecb8cb33651c9ebc85fb60c03ea20bbf2cf2ab9ace585bf781a9970dcf92d935d33e0a5eaca6f697da163dbc1ccb662b1dfad21885d5318ab7d78d2f33b96d380eff2950aa7eb1a59675275948c6297126978e18d38fcffc7439a5538a7cacc780b971040fdbf446d870d20bbdd43aa506b48fcdae3386d087714aa3ddc7490a6064dd5ae68d5d581ed109925c1d4e3d3f233872ab58c89b6bb70e4964b714883de597369ad798b94a61f73e4d1a5985bd5f7ba61ef8a8568b5e871e7a8ebdd787fe0858b283c508433834355fe6498b38d85daf8204fcada85f48a19609f931bb08f0c05f569b40d2ebf962d512055bd92722a8c96cc6226b6d614a9acaaa4d1b7e41ec96327a348dd6c4afe7b4a41c5054f7fa233ec2272343858cedb7633ed5d9d393f391a1bf2a4e0946942c7a4c834ab67520465466b5072427e432015b61062ef9d95c2c5a5b932caa20a09465ace643a4cbb73ce7ecef2bd527b0cc74104c28b8c239a6943b8b130fe83902f55da861d364c80b8b9930330960ff6e9db7ff8a510cdd38658625b58daaae98ab28b6c28f0e278606c592cc74a91412939e5f1a513086aed90a31f0e076cd6e4a758c65412c860de8378ba9f40c9722610ba4224ae8d32e25fc52a943196144122224079971fd52f6ff84f60612721216f6483d313fffac298005c4120715aa7ec09c5142d00ed8c97e81cd363141f301e284dfe77d493be07683d19c540955b3c088e9ab1727db5d24c994534f506afda41fc160fbef6d68bfd04fdbc0f94a222f52b9bfad8eb5bdccd676ee257be38e7f0d4bbb198294d0071bf44c74714f428de30d33ce1205718810c2d1f6452647ededb1498e9dee26c7e36fa55afb98c86f2bc1c0413bbca7cc79ab7b0df2a58e2fae6edc43e6a04c74852b14d938608ce39fa04b844872427ab9bff36b566547b0ace6329bc49247a8147f90420d02efffabc9f82ac15cfe35e432c12441e8a6a453b8a1b6294430d17de3404edc189f2b74e8190c106e21ff4f32209231e3bdc319791fd861ddbc8cbe754923d49d66ad6bbc18e37044470e76e2d92e1dc6ae588cf97aa2ce1d90e0f5c7c9c1bf99f8da121165df6cf490b97748a95df6eff72ee4f794c5c328d1a78c49a3c6f878259e6cd629075e9ba0123ee5d81a58f44afe73db2649e2e653404767916c9a76dd69256ebde17b1a802e592233c107764b5cd558846c370d5257f565735fe45acfd5423a94a986a1a74e1efd27a255b15908cdbe1611db17579c005b4f4621ca7e338b93d08c48009dd8b25f75d5deb2417a6681f5700b0c2b5ebd1ac05ff67ff170fa3220d8b5df6938a60b2782b3ff44f7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
